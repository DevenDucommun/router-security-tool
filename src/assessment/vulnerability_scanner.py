"""
Vulnerability Scanner
Main vulnerability assessment engine that correlates service data with CVE database
"""

import logging
import re
from typing import List, Dict, Optional
from database.cve_manager import CVEManager
from assessment.service_scanner import ServiceScanner

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Main vulnerability scanner that correlates services with known vulnerabilities"""
    
    def __init__(self):
        self.cve_manager = CVEManager()
        self.service_scanner = ServiceScanner()
        self.vendor_patterns = self._build_vendor_patterns()
        
    def _build_vendor_patterns(self) -> Dict[str, List[str]]:
        """Build regex patterns for identifying vendors from service banners"""
        return {
            'cisco': [
                r'cisco',
                r'ios',
                r'nx-os',
                r'asa',
                r'pix'
            ],
            'linksys': [
                r'linksys',
                r'velop'
            ],
            'netgear': [
                r'netgear',
                r'readynas',
                r'prosafe'
            ],
            'tplink': [
                r'tp-?link',
                r'archer',
                r'deco'
            ],
            'dlink': [
                r'd-?link',
                r'dir-',
                r'dcs-'
            ],
            'asus': [
                r'asus',
                r'rt-',
                r'ac[0-9]+'
            ],
            'buffalo': [
                r'buffalo',
                r'airstation'
            ],
            'ubiquiti': [
                r'ubiquiti',
                r'unifi',
                r'edgeos'
            ]
        }
    
    def scan_target(self, host: str, connection_info: Dict = None) -> Dict:
        """Perform comprehensive vulnerability scan of target"""
        logger.info(f"Starting vulnerability scan of {host}")
        
        scan_results = {
            "target": host,
            "scan_timestamp": None,
            "device_info": {},
            "services": {},
            "vulnerabilities": [],
            "risk_score": 0.0,
            "recommendations": []
        }
        
        # Step 1: Network service enumeration
        logger.info("Performing service enumeration")
        service_results = self.service_scanner.scan_host(host)
        scan_results.update({
            "scan_timestamp": service_results.get("scan_time"),
            "services": service_results
        })
        
        # Step 2: Device identification
        device_info = self._identify_device(service_results)
        scan_results["device_info"] = device_info
        
        # Step 3: CVE correlation for identified services
        logger.info("Correlating services with CVE database")
        service_vulns = self._correlate_service_vulnerabilities(service_results, device_info)
        scan_results["vulnerabilities"].extend(service_vulns)
        
        # Step 4: Protocol-specific vulnerability checks
        protocol_vulns = self._analyze_protocol_vulnerabilities(service_results)
        scan_results["vulnerabilities"].extend(protocol_vulns)
        
        # Step 5: Configuration-based vulnerabilities (if connection available)
        if connection_info:
            config_vulns = self._analyze_configuration_vulnerabilities(connection_info)
            scan_results["vulnerabilities"].extend(config_vulns)
        
        # Step 6: Risk scoring
        risk_score = self._calculate_risk_score(scan_results["vulnerabilities"])
        scan_results["risk_score"] = risk_score
        
        # Step 7: Generate recommendations
        recommendations = self._generate_recommendations(scan_results)
        scan_results["recommendations"] = recommendations
        
        logger.info(f"Vulnerability scan complete for {host}: "
                   f"{len(scan_results['vulnerabilities'])} vulnerabilities found, "
                   f"risk score: {risk_score:.1f}")
        
        return scan_results
    
    def _identify_device(self, service_results: Dict) -> Dict:
        """Identify device vendor, model, and version from service information"""
        device_info = {
            "vendor": "unknown",
            "product": "unknown", 
            "version": "unknown",
            "device_type": "network_device",
            "confidence": 0.0
        }
        
        banners = service_results.get("banners", {})
        services = service_results.get("services", {})
        
        # Analyze all banners for vendor identification
        all_text = " ".join([str(banner) for banner in banners.values()]).lower()
        all_text += " ".join([str(service) for service in services.values()]).lower()
        
        vendor_scores = {}
        
        # Score vendors based on pattern matches
        for vendor, patterns in self.vendor_patterns.items():
            score = 0
            for pattern in patterns:
                matches = len(re.findall(pattern, all_text, re.IGNORECASE))
                score += matches * (1.0 / len(patterns))
            
            if score > 0:
                vendor_scores[vendor] = score
        
        if vendor_scores:
            # Select vendor with highest score
            best_vendor = max(vendor_scores, key=vendor_scores.get)
            device_info["vendor"] = best_vendor
            device_info["confidence"] = min(vendor_scores[best_vendor], 1.0)
            
            # Try to extract product/version information
            product_version = self._extract_product_version(best_vendor, all_text, banners)
            if product_version:
                device_info.update(product_version)
        
        # Determine device type based on services
        device_info["device_type"] = self._classify_device_type(service_results)
        
        logger.info(f"Device identified: {device_info['vendor']} {device_info['product']} "
                   f"(confidence: {device_info['confidence']:.2f})")
        
        return device_info
    
    def _extract_product_version(self, vendor: str, text: str, banners: Dict) -> Optional[Dict]:
        """Extract product and version information for specific vendor"""
        result = {}
        
        if vendor == "cisco":
            # Look for IOS version
            ios_match = re.search(r'ios.*?version\s+([\\d\\.\\w]+)', text, re.IGNORECASE)
            if ios_match:
                result["product"] = "ios"
                result["version"] = ios_match.group(1)
            
            # Look for device model
            model_patterns = [
                r'cisco\\s+(\\w+[-\\w]*)',
                r'(c[0-9]+[\\w-]+)',
                r'(asr[0-9]+)',
                r'(catalyst\\s+[0-9]+)'
            ]
            for pattern in model_patterns:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    result["product"] = match.group(1).lower()
                    break
        
        elif vendor == "linksys":
            # Look for Linksys model
            model_match = re.search(r'(ea[0-9]+|wrt[0-9]+|mr[0-9]+)', text, re.IGNORECASE)
            if model_match:
                result["product"] = model_match.group(1).lower()
        
        elif vendor == "netgear":
            # Look for Netgear model
            model_match = re.search(r'(r[0-9]+|wnr[0-9]+|c[0-9]+)', text, re.IGNORECASE)
            if model_match:
                result["product"] = model_match.group(1).lower()
        
        return result if result else None
    
    def _classify_device_type(self, service_results: Dict) -> str:
        """Classify device type based on running services"""
        services = service_results.get("services", {})
        open_ports = service_results.get("open_ports", [])
        
        # Router indicators
        router_indicators = [53, 67, 68]  # DNS, DHCP
        if any(port in open_ports for port in router_indicators):
            return "router"
        
        # Switch indicators  
        switch_indicators = [161, 162]  # SNMP
        if any(port in open_ports for port in switch_indicators):
            return "switch"
        
        # Wireless indicators
        if any("wireless" in str(service).lower() or "wifi" in str(service).lower() 
               for service in services.values()):
            return "wireless_router"
        
        # Default to network device
        return "network_device"
    
    def _correlate_service_vulnerabilities(self, service_results: Dict, 
                                         device_info: Dict) -> List[Dict]:
        """Correlate detected services with CVE database"""
        vulnerabilities = []
        
        vendor = device_info.get("vendor", "unknown")
        product = device_info.get("product", "unknown")
        version = device_info.get("version")
        
        # Search CVE database for device-specific vulnerabilities
        if vendor != "unknown" and product != "unknown":
            logger.info(f"Searching CVEs for {vendor} {product}")
            
            # First try with specific version
            if version and version != "unknown":
                cves = self.cve_manager.search_cves_by_product(vendor, product, version)
            else:
                cves = self.cve_manager.search_cves_by_product(vendor, product)
            
            # If no results and we haven't tried fetching from API recently
            if not cves:
                logger.info(f"No local CVEs found, fetching from NVD API")
                api_cves = self.cve_manager.fetch_cves_for_vendor(vendor, product, max_results=500)
                if api_cves:
                    # Retry search with newly fetched data
                    if version and version != "unknown":
                        cves = self.cve_manager.search_cves_by_product(vendor, product, version)
                    else:
                        cves = self.cve_manager.search_cves_by_product(vendor, product)
            
            # Convert CVEs to vulnerability objects
            for cve in cves[:20]:  # Limit to top 20 by CVSS score
                vuln = {
                    "id": cve["cve_id"],
                    "type": "CVE",
                    "severity": self._cvss_to_severity(cve.get("cvss_v3_score") or cve.get("cvss_v2_score")),
                    "cvss_score": cve.get("cvss_v3_score") or cve.get("cvss_v2_score"),
                    "title": f"CVE {cve['cve_id']} - {vendor.title()} {product.title()}",
                    "description": cve["description"][:300] + "..." if len(cve["description"]) > 300 else cve["description"],
                    "published_date": cve["published_date"],
                    "references": cve.get("references", [])[:3],  # Limit references
                    "affected_component": f"{vendor} {product}",
                    "remediation": self._generate_cve_remediation(cve)
                }
                vulnerabilities.append(vuln)
        
        # Service-specific vulnerabilities
        services = service_results.get("services", {})
        for port, service in services.items():
            service_vulns = self._get_service_specific_vulnerabilities(port, service)
            vulnerabilities.extend(service_vulns)
        
        return vulnerabilities
    
    def _analyze_protocol_vulnerabilities(self, service_results: Dict) -> List[Dict]:
        """Analyze protocols for inherent security issues"""
        vulnerabilities = []
        
        protocol_issues = service_results.get("protocol_issues", [])
        
        for issue in protocol_issues:
            vuln = {
                "id": f"PROTO-{issue['port']}-{issue['protocol']}",
                "type": "Protocol Vulnerability",
                "severity": issue["severity"],
                "cvss_score": self._severity_to_cvss(issue["severity"]),
                "title": f"Insecure Protocol: {issue['protocol']} on port {issue['port']}",
                "description": issue["issue"],
                "affected_component": f"Port {issue['port']} ({issue['protocol']})",
                "remediation": issue["recommendation"]
            }
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _analyze_configuration_vulnerabilities(self, connection_info: Dict) -> List[Dict]:
        """Analyze configuration for vulnerabilities (requires device connection)"""
        vulnerabilities = []
        
        # This would analyze actual device configuration
        # For now, return placeholder based on connection type
        if connection_info.get("type") == "telnet":
            vulnerabilities.append({
                "id": "CONFIG-TELNET-ENABLED",
                "type": "Configuration Vulnerability",
                "severity": "High",
                "cvss_score": 7.5,
                "title": "Telnet Service Enabled",
                "description": "Device accepts Telnet connections which transmit credentials in plaintext",
                "affected_component": "Remote Access Configuration",
                "remediation": "Disable Telnet and enable SSH with strong authentication"
            })
        
        return vulnerabilities
    
    def _get_service_specific_vulnerabilities(self, port: int, service: str) -> List[Dict]:
        """Get vulnerabilities specific to detected services"""
        vulnerabilities = []
        service_lower = service.lower()
        
        # Web interface vulnerabilities
        if port in [80, 8080, 443, 8443] and "http" in service_lower:
            vulnerabilities.append({
                "id": f"WEB-{port}",
                "type": "Service Vulnerability",
                "severity": "Medium",
                "cvss_score": 5.3,
                "title": f"Web Management Interface Exposed on port {port}",
                "description": "Web management interface may be vulnerable to common web attacks",
                "affected_component": f"Web Interface (port {port})",
                "remediation": "Restrict access to management interface, enable strong authentication, keep firmware updated"
            })
        
        # SNMP vulnerabilities
        if port == 161 and "snmp" in service_lower:
            severity = "High" if "v1" in service_lower or "v2c" in service_lower else "Medium"
            vulnerabilities.append({
                "id": "SNMP-WEAK-AUTH",
                "type": "Service Vulnerability", 
                "severity": severity,
                "cvss_score": 7.5 if severity == "High" else 5.3,
                "title": "SNMP Service with Weak Authentication",
                "description": "SNMP service may use default or weak community strings",
                "affected_component": f"SNMP Service (port {port})",
                "remediation": "Use SNMPv3 with strong authentication and encryption, change default community strings"
            })
        
        return vulnerabilities
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """Calculate overall risk score based on vulnerabilities"""
        if not vulnerabilities:
            return 0.0
        
        total_score = 0.0
        count = 0
        
        for vuln in vulnerabilities:
            cvss_score = vuln.get("cvss_score")
            if cvss_score:
                total_score += cvss_score
                count += 1
        
        if count == 0:
            return 0.0
        
        # Calculate weighted average with diminishing returns
        avg_score = total_score / count
        severity_multiplier = min(len(vulnerabilities) / 10.0, 1.5)  # Cap at 1.5x
        
        return min(avg_score * severity_multiplier, 10.0)
    
    def _generate_recommendations(self, scan_results: Dict) -> List[Dict]:
        """Generate security recommendations based on findings"""
        recommendations = []
        vulnerabilities = scan_results.get("vulnerabilities", [])
        
        # Group recommendations by type
        recommendations_map = {}
        
        for vuln in vulnerabilities:
            remediation = vuln.get("remediation", "")
            if remediation and remediation not in recommendations_map:
                recommendations_map[remediation] = {
                    "recommendation": remediation,
                    "priority": self._severity_to_priority(vuln.get("severity", "Low")),
                    "affected_components": [],
                    "vulnerability_count": 0
                }
            
            if remediation:
                rec = recommendations_map[remediation]
                component = vuln.get("affected_component", "Unknown")
                if component not in rec["affected_components"]:
                    rec["affected_components"].append(component)
                rec["vulnerability_count"] += 1
        
        # Convert to list and sort by priority
        for rec_data in recommendations_map.values():
            recommendations.append(rec_data)
        
        recommendations.sort(key=lambda x: x["priority"], reverse=True)
        
        return recommendations[:10]  # Top 10 recommendations
    
    def _cvss_to_severity(self, cvss_score: Optional[float]) -> str:
        """Convert CVSS score to severity level"""
        if not cvss_score:
            return "Unknown"
        
        if cvss_score >= 9.0:
            return "Critical"
        elif cvss_score >= 7.0:
            return "High"
        elif cvss_score >= 4.0:
            return "Medium"
        else:
            return "Low"
    
    def _severity_to_cvss(self, severity: str) -> float:
        """Convert severity level to approximate CVSS score"""
        severity_map = {
            "Critical": 9.5,
            "High": 7.5,
            "Medium": 5.0,
            "Low": 2.0
        }
        return severity_map.get(severity, 0.0)
    
    def _severity_to_priority(self, severity: str) -> int:
        """Convert severity to numeric priority"""
        priority_map = {
            "Critical": 4,
            "High": 3,
            "Medium": 2,
            "Low": 1
        }
        return priority_map.get(severity, 0)
    
    def _generate_cve_remediation(self, cve: Dict) -> str:
        """Generate remediation advice for CVE"""
        description = cve.get("description", "").lower()
        
        if "update" in description or "patch" in description:
            return "Update device firmware to the latest version"
        elif "authentication" in description or "password" in description:
            return "Change default passwords and implement strong authentication"
        elif "configuration" in description:
            return "Review and harden device configuration settings"
        else:
            return "Consult vendor security advisories for specific remediation steps"
    
    def update_cve_database(self):
        """Update the CVE database with latest data"""
        logger.info("Updating CVE database")
        return self.cve_manager.update_database()
    
    def get_database_stats(self):
        """Get CVE database statistics"""
        return self.cve_manager.get_database_stats()