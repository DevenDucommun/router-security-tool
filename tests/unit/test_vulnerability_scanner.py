"""
Unit tests for Vulnerability Scanner module
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from src.assessment.vulnerability_scanner import VulnerabilityScanner


@pytest.fixture
def vuln_scanner():
    """Create a VulnerabilityScanner instance with mocked dependencies"""
    with patch(
        "src.assessment.vulnerability_scanner.CVEManager"
    ), patch("src.assessment.vulnerability_scanner.ServiceScanner"):
        scanner = VulnerabilityScanner()
        return scanner


@pytest.fixture
def mock_service_results():
    """Mock service scan results"""
    return {
        "host": "192.168.1.1",
        "scan_time": 1234567890,
        "open_ports": [22, 80, 443],
        "services": {
            22: "SSH 2.0 (OpenSSH)",
            80: "HTTP - nginx/1.14.0",
            443: "HTTPS",
        },
        "banners": {
            22: "SSH-2.0-OpenSSH_7.4",
            80: "Server: nginx/1.14.0",
        },
        "protocol_issues": [
            {
                "port": 80,
                "protocol": "HTTP",
                "severity": "Medium",
                "issue": "Unencrypted web interface",
                "recommendation": "Enable HTTPS",
            }
        ],
    }


@pytest.fixture
def mock_cve_data():
    """Mock CVE data"""
    return [
        {
            "cve_id": "CVE-2023-12345",
            "description": "Buffer overflow vulnerability in Cisco router firmware",
            "cvss_v3_score": 8.5,
            "cvss_v2_score": None,
            "published_date": "2023-01-15",
            "cve_references": ["https://example.com/cve-2023-12345"],
        },
        {
            "cve_id": "CVE-2023-67890",
            "description": "Authentication bypass in web interface",
            "cvss_v3_score": 9.1,
            "cvss_v2_score": None,
            "published_date": "2023-02-20",
            "cve_references": ["https://example.com/cve-2023-67890"],
        },
    ]


class TestVulnerabilityScannerInit:
    """Test VulnerabilityScanner initialization"""

    @patch("src.assessment.vulnerability_scanner.CVEManager")
    @patch("src.assessment.vulnerability_scanner.ServiceScanner")
    def test_init_creates_dependencies(self, mock_service, mock_cve):
        """Test that dependencies are initialized"""
        scanner = VulnerabilityScanner()

        assert scanner.cve_manager is not None
        assert scanner.service_scanner is not None
        assert scanner.vendor_patterns is not None
        assert len(scanner.vendor_patterns) > 0

    def test_vendor_patterns_include_common_vendors(self, vuln_scanner):
        """Test that common router vendors are in patterns"""
        assert "cisco" in vuln_scanner.vendor_patterns
        assert "linksys" in vuln_scanner.vendor_patterns
        assert "netgear" in vuln_scanner.vendor_patterns
        assert "tplink" in vuln_scanner.vendor_patterns


class TestDeviceIdentification:
    """Test device identification methods"""

    def test_identify_device_cisco(self, vuln_scanner):
        """Test identification of Cisco device"""
        service_results = {
            "banners": {
                22: "SSH-2.0-Cisco-1.25",
                23: "Cisco IOS Software, Version 15.1",
            },
            "services": {22: "SSH", 23: "Telnet"},
        }

        device_info = vuln_scanner._identify_device(service_results)

        assert device_info["vendor"] == "cisco"
        assert device_info["confidence"] > 0
        assert device_info["device_type"] in [
            "router",
            "switch",
            "network_device",
        ]

    def test_identify_device_linksys(self, vuln_scanner):
        """Test identification of Linksys device"""
        service_results = {
            "banners": {80: "Server: Linksys Router"},
            "services": {80: "HTTP - Linksys EA6350"},
        }

        device_info = vuln_scanner._identify_device(service_results)

        assert device_info["vendor"] == "linksys"
        assert device_info["confidence"] > 0

    def test_identify_device_netgear(self, vuln_scanner):
        """Test identification of Netgear device"""
        service_results = {
            "banners": {80: "Netgear R7000 Router"},
            "services": {80: "HTTP"},
        }

        device_info = vuln_scanner._identify_device(service_results)

        assert device_info["vendor"] == "netgear"

    def test_identify_device_unknown(self, vuln_scanner):
        """Test identification with no matching vendor"""
        service_results = {"banners": {}, "services": {22: "SSH"}}

        device_info = vuln_scanner._identify_device(service_results)

        assert device_info["vendor"] == "unknown"
        assert device_info["confidence"] == 0.0

    def test_extract_product_version_cisco(self, vuln_scanner):
        """Test extraction of Cisco product and version"""
        text = "cisco ios software version 15.1.4m ios catalyst 3750"
        banners = {}

        result = vuln_scanner._extract_product_version("cisco", text, banners)

        # Result may be None if pattern doesn't match exactly
        if result:
            assert "product" in result or "version" in result

    def test_extract_product_version_linksys(self, vuln_scanner):
        """Test extraction of Linksys product model"""
        text = "linksys ea6350 router web interface"
        banners = {}

        result = vuln_scanner._extract_product_version(
            "linksys", text, banners
        )

        assert result is not None
        assert "product" in result
        assert "ea6350" in result["product"].lower()

    def test_extract_product_version_no_match(self, vuln_scanner):
        """Test extraction with no product match"""
        text = "generic router firmware"
        banners = {}

        result = vuln_scanner._extract_product_version("cisco", text, banners)

        assert result is None


class TestDeviceTypeClassification:
    """Test device type classification"""

    def test_classify_router(self, vuln_scanner):
        """Test classification of router based on services"""
        service_results = {"services": {}, "open_ports": [53, 67, 80]}

        device_type = vuln_scanner._classify_device_type(service_results)

        assert device_type == "router"

    def test_classify_switch(self, vuln_scanner):
        """Test classification of switch based on SNMP"""
        service_results = {"services": {}, "open_ports": [161, 162]}

        device_type = vuln_scanner._classify_device_type(service_results)

        assert device_type == "switch"

    def test_classify_wireless_router(self, vuln_scanner):
        """Test classification of wireless router"""
        service_results = {
            "services": {80: "Wireless Router Admin"},
            "open_ports": [80],
        }

        device_type = vuln_scanner._classify_device_type(service_results)

        assert device_type == "wireless_router"

    def test_classify_generic_network_device(self, vuln_scanner):
        """Test classification of generic network device"""
        service_results = {"services": {22: "SSH"}, "open_ports": [22]}

        device_type = vuln_scanner._classify_device_type(service_results)

        assert device_type == "network_device"


class TestCVECorrelation:
    """Test CVE correlation functionality"""

    def test_correlate_service_vulnerabilities_with_cves(
        self, vuln_scanner, mock_cve_data
    ):
        """Test correlation of services with CVE database"""
        service_results = {
            "services": {22: "SSH"},
            "open_ports": [22],
        }
        device_info = {
            "vendor": "cisco",
            "product": "ios",
            "version": "15.1",
        }

        vuln_scanner.cve_manager.search_cves_by_product.return_value = (
            mock_cve_data
        )

        vulnerabilities = vuln_scanner._correlate_service_vulnerabilities(
            service_results, device_info
        )

        assert len(vulnerabilities) > 0
        assert any(v["type"] == "CVE" for v in vulnerabilities)
        vuln_scanner.cve_manager.search_cves_by_product.assert_called()

    def test_correlate_service_vulnerabilities_fetch_from_api(
        self, vuln_scanner, mock_cve_data
    ):
        """Test fetching CVEs from API when not in local database"""
        service_results = {"services": {}, "open_ports": []}
        device_info = {
            "vendor": "cisco",
            "product": "ios",
            "version": "15.1",
        }

        # First call returns empty, second returns data after API fetch
        vuln_scanner.cve_manager.search_cves_by_product.side_effect = [
            [],
            mock_cve_data,
        ]
        vuln_scanner.cve_manager.fetch_cves_for_vendor.return_value = (
            mock_cve_data
        )

        vulnerabilities = vuln_scanner._correlate_service_vulnerabilities(
            service_results, device_info
        )

        vuln_scanner.cve_manager.fetch_cves_for_vendor.assert_called_once()

    def test_correlate_service_vulnerabilities_unknown_device(
        self, vuln_scanner
    ):
        """Test correlation with unknown device"""
        service_results = {"services": {}, "open_ports": []}
        device_info = {"vendor": "unknown", "product": "unknown"}

        vulnerabilities = vuln_scanner._correlate_service_vulnerabilities(
            service_results, device_info
        )

        # Should not call CVE manager for unknown devices
        vuln_scanner.cve_manager.search_cves_by_product.assert_not_called()


class TestProtocolVulnerabilityAnalysis:
    """Test protocol vulnerability analysis"""

    def test_analyze_protocol_vulnerabilities(self, vuln_scanner):
        """Test analysis of protocol security issues"""
        service_results = {
            "protocol_issues": [
                {
                    "port": 23,
                    "protocol": "Telnet",
                    "severity": "High",
                    "issue": "Unencrypted protocol",
                    "recommendation": "Use SSH",
                }
            ]
        }

        vulnerabilities = vuln_scanner._analyze_protocol_vulnerabilities(
            service_results
        )

        assert len(vulnerabilities) > 0
        assert vulnerabilities[0]["type"] == "Protocol Vulnerability"
        assert vulnerabilities[0]["severity"] == "High"

    def test_analyze_protocol_vulnerabilities_empty(self, vuln_scanner):
        """Test analysis with no protocol issues"""
        service_results = {"protocol_issues": []}

        vulnerabilities = vuln_scanner._analyze_protocol_vulnerabilities(
            service_results
        )

        assert len(vulnerabilities) == 0


class TestServiceSpecificVulnerabilities:
    """Test service-specific vulnerability detection"""

    def test_get_service_specific_vulnerabilities_web(self, vuln_scanner):
        """Test detection of web service vulnerabilities"""
        vulnerabilities = vuln_scanner._get_service_specific_vulnerabilities(
            80, "HTTP"
        )

        assert len(vulnerabilities) > 0
        assert any("Web" in v["title"] for v in vulnerabilities)

    def test_get_service_specific_vulnerabilities_snmp(self, vuln_scanner):
        """Test detection of SNMP vulnerabilities"""
        vulnerabilities = vuln_scanner._get_service_specific_vulnerabilities(
            161, "SNMP v2c"
        )

        assert len(vulnerabilities) > 0
        assert any(v["severity"] == "High" for v in vulnerabilities)

    def test_get_service_specific_vulnerabilities_snmpv3(self, vuln_scanner):
        """Test detection of SNMPv3 (should be less severe)"""
        vulnerabilities = vuln_scanner._get_service_specific_vulnerabilities(
            161, "SNMP v3"
        )

        # SNMPv3 should have lower severity than v1/v2c
        if vulnerabilities:
            assert all(v["severity"] != "Critical" for v in vulnerabilities)


class TestRiskScoring:
    """Test risk score calculation"""

    def test_calculate_risk_score_no_vulnerabilities(self, vuln_scanner):
        """Test risk score with no vulnerabilities"""
        risk_score = vuln_scanner._calculate_risk_score([])

        assert risk_score == 0.0

    def test_calculate_risk_score_single_high(self, vuln_scanner):
        """Test risk score with single high severity vulnerability"""
        vulnerabilities = [{"cvss_score": 7.5, "severity": "High"}]

        risk_score = vuln_scanner._calculate_risk_score(vulnerabilities)

        assert risk_score > 0
        assert risk_score <= 10.0

    def test_calculate_risk_score_multiple_vulnerabilities(
        self, vuln_scanner
    ):
        """Test risk score with multiple vulnerabilities"""
        vulnerabilities = [
            {"cvss_score": 9.0, "severity": "Critical"},
            {"cvss_score": 7.5, "severity": "High"},
            {"cvss_score": 5.0, "severity": "Medium"},
        ]

        risk_score = vuln_scanner._calculate_risk_score(vulnerabilities)

        assert risk_score > 0
        assert risk_score <= 10.0

    def test_calculate_risk_score_capped_at_10(self, vuln_scanner):
        """Test that risk score is capped at 10.0"""
        vulnerabilities = [
            {"cvss_score": 10.0, "severity": "Critical"} for _ in range(100)
        ]

        risk_score = vuln_scanner._calculate_risk_score(vulnerabilities)

        assert risk_score == 10.0


class TestRecommendationGeneration:
    """Test security recommendation generation"""

    def test_generate_recommendations(self, vuln_scanner):
        """Test generation of security recommendations"""
        scan_results = {
            "vulnerabilities": [
                {
                    "severity": "High",
                    "remediation": "Update firmware to latest version",
                    "affected_component": "Router Firmware",
                },
                {
                    "severity": "Medium",
                    "remediation": "Enable strong authentication",
                    "affected_component": "Web Interface",
                },
                {
                    "severity": "High",
                    "remediation": "Update firmware to latest version",
                    "affected_component": "SSH Service",
                },
            ]
        }

        recommendations = vuln_scanner._generate_recommendations(scan_results)

        assert len(recommendations) > 0
        assert all("recommendation" in r for r in recommendations)
        assert all("priority" in r for r in recommendations)

    def test_generate_recommendations_deduplication(self, vuln_scanner):
        """Test that duplicate recommendations are merged"""
        scan_results = {
            "vulnerabilities": [
                {
                    "severity": "High",
                    "remediation": "Update firmware",
                    "affected_component": "Component A",
                },
                {
                    "severity": "High",
                    "remediation": "Update firmware",
                    "affected_component": "Component B",
                },
            ]
        }

        recommendations = vuln_scanner._generate_recommendations(scan_results)

        # Should have only one "Update firmware" recommendation
        update_recs = [
            r for r in recommendations if "Update firmware" in r["recommendation"]
        ]
        assert len(update_recs) == 1
        assert update_recs[0]["vulnerability_count"] == 2

    def test_generate_recommendations_sorted_by_priority(self, vuln_scanner):
        """Test that recommendations are sorted by priority"""
        scan_results = {
            "vulnerabilities": [
                {
                    "severity": "Low",
                    "remediation": "Low priority fix",
                    "affected_component": "A",
                },
                {
                    "severity": "Critical",
                    "remediation": "Critical fix",
                    "affected_component": "B",
                },
                {
                    "severity": "Medium",
                    "remediation": "Medium fix",
                    "affected_component": "C",
                },
            ]
        }

        recommendations = vuln_scanner._generate_recommendations(scan_results)

        # First recommendation should have highest priority
        priorities = [r["priority"] for r in recommendations]
        assert priorities == sorted(priorities, reverse=True)


class TestUtilityMethods:
    """Test utility methods"""

    def test_cvss_to_severity_critical(self, vuln_scanner):
        """Test CVSS to severity conversion for critical"""
        severity = vuln_scanner._cvss_to_severity(9.5)
        assert severity == "Critical"

    def test_cvss_to_severity_high(self, vuln_scanner):
        """Test CVSS to severity conversion for high"""
        severity = vuln_scanner._cvss_to_severity(7.5)
        assert severity == "High"

    def test_cvss_to_severity_medium(self, vuln_scanner):
        """Test CVSS to severity conversion for medium"""
        severity = vuln_scanner._cvss_to_severity(5.0)
        assert severity == "Medium"

    def test_cvss_to_severity_low(self, vuln_scanner):
        """Test CVSS to severity conversion for low"""
        severity = vuln_scanner._cvss_to_severity(2.0)
        assert severity == "Low"

    def test_cvss_to_severity_none(self, vuln_scanner):
        """Test CVSS to severity conversion with None"""
        severity = vuln_scanner._cvss_to_severity(None)
        assert severity == "Unknown"

    def test_severity_to_cvss(self, vuln_scanner):
        """Test severity to CVSS conversion"""
        assert vuln_scanner._severity_to_cvss("Critical") == 9.5
        assert vuln_scanner._severity_to_cvss("High") == 7.5
        assert vuln_scanner._severity_to_cvss("Medium") == 5.0
        assert vuln_scanner._severity_to_cvss("Low") == 2.0

    def test_severity_to_priority(self, vuln_scanner):
        """Test severity to priority conversion"""
        assert vuln_scanner._severity_to_priority("Critical") == 4
        assert vuln_scanner._severity_to_priority("High") == 3
        assert vuln_scanner._severity_to_priority("Medium") == 2
        assert vuln_scanner._severity_to_priority("Low") == 1

    def test_generate_cve_remediation_update(self, vuln_scanner):
        """Test CVE remediation generation for update"""
        cve = {"description": "Fixed in firmware update version 2.0"}
        remediation = vuln_scanner._generate_cve_remediation(cve)
        assert "update" in remediation.lower() or "firmware" in remediation.lower()

    def test_generate_cve_remediation_authentication(self, vuln_scanner):
        """Test CVE remediation generation for authentication issue"""
        cve = {"description": "Default password authentication bypass"}
        remediation = vuln_scanner._generate_cve_remediation(cve)
        assert "authentication" in remediation.lower() or "password" in remediation.lower()


class TestFullScan:
    """Test full vulnerability scan"""

    def test_scan_target_complete_workflow(
        self, vuln_scanner, mock_service_results
    ):
        """Test complete vulnerability scan workflow"""
        vuln_scanner.service_scanner.scan_host.return_value = (
            mock_service_results
        )
        vuln_scanner.cve_manager.search_cves_by_product.return_value = []

        results = vuln_scanner.scan_target("192.168.1.1")

        assert results["target"] == "192.168.1.1"
        assert "device_info" in results
        assert "services" in results
        assert "vulnerabilities" in results
        assert "risk_score" in results
        assert "recommendations" in results
        assert results["risk_score"] >= 0

    def test_scan_target_with_connection_info(
        self, vuln_scanner, mock_service_results
    ):
        """Test scan with connection info for config analysis"""
        vuln_scanner.service_scanner.scan_host.return_value = (
            mock_service_results
        )
        vuln_scanner.cve_manager.search_cves_by_product.return_value = []

        connection_info = {"type": "telnet", "host": "192.168.1.1"}

        results = vuln_scanner.scan_target("192.168.1.1", connection_info)

        # Should include configuration vulnerabilities
        assert any(
            "CONFIG" in v.get("id", "")
            for v in results.get("vulnerabilities", [])
        )


class TestDatabaseOperations:
    """Test database-related operations"""

    def test_update_cve_database(self, vuln_scanner):
        """Test CVE database update"""
        vuln_scanner.cve_manager.update_database.return_value = True

        result = vuln_scanner.update_cve_database()

        vuln_scanner.cve_manager.update_database.assert_called_once()
        assert result is True

    def test_get_database_stats(self, vuln_scanner):
        """Test getting database statistics"""
        mock_stats = {"total_cves": 1000, "vendors": 50}
        vuln_scanner.cve_manager.get_database_stats.return_value = mock_stats

        stats = vuln_scanner.get_database_stats()

        assert stats == mock_stats
        vuln_scanner.cve_manager.get_database_stats.assert_called_once()
